import re

class BaseAnalyzer:
    SEVERITY_WEIGHTS = {
        "critical": 20,
        "high": 10,
        "medium": 5,
        "low": 2
    }
    
    def calculate_score(self, issues):
        base_score = 100
        total_penalty = sum([self.SEVERITY_WEIGHTS[issue["severity"]] for issue in issues])
        total_penalty = min(total_penalty, base_score)  # Cap the penalty to the base score
        return max(0, base_score - total_penalty)

class JavaScriptAnalyzer(BaseAnalyzer):
    def __init__(self, code):
        self.code = code

    def analyze(self):
        issues = []
        issues.extend(self.check_hardcoded_secrets())
        issues.extend(self.check_use_of_eval())
        issues.extend(self.check_document_write())
        issues.extend(self.check_weak_crypto())
        issues.extend(self.check_hardcoded_ips())
        issues.extend(self.check_deprecated_libraries())
        issues.extend(self.check_insecure_http_urls())
        issues.extend(self.check_ineffective_security_headers())
        issues.extend(self.check_inner_html_usage())
        issues.extend(self.check_insecure_event_handlers())
        score = self.calculate_score(issues)
        return {"score": score, "issues": issues}

    def check_hardcoded_secrets(self):
        issues = []
        secret_patterns = {
            "API Key": re.compile(r'["\'][A-Za-z0-9_\-]{35,}["\']'),
            "Password": re.compile(r'["\'][^"\']*password[^"\']*["\']', re.IGNORECASE)
        }

        for line_num, line in enumerate(self.code.split('\n'), start=1):
            for secret_name, pattern in secret_patterns.items():
                if pattern.search(line):
                    issues.append({
                        "line": line_num,
                        "message": f"Possible hardcoded {secret_name} found",
                        "fix": "Store secrets in environment variables or configuration files.",
                        "severity": "high"
                    })
        return issues

    def check_use_of_eval(self):
        issues = []
        for line_num, line in enumerate(self.code.split('\n'), start=1):
            if "eval(" in line:
                issues.append({
                    "line": line_num,
                    "message": "Use of eval function found",
                    "fix": "Avoid using eval function or sanitize inputs properly.",
                    "severity": "high"
                })
        return issues

    def check_document_write(self):
        issues = []
        for line_num, line in enumerate(self.code.split('\n'), start=1):
            if "document.write(" in line:
                issues.append({
                    "line": line_num,
                    "message": "Use of document.write function found",
                    "fix": "Avoid using document.write function or sanitize inputs properly.",
                    "severity": "high"
                })
        return issues

    def check_weak_crypto(self):
        issues = []
        weak_crypto_patterns = [
            re.compile(r'crypto.createHash\(["\']md5["\']\)'),
            re.compile(r'crypto.createHash\(["\']sha1["\']\)')
        ]

        for line_num, line in enumerate(self.code.split('\n'), start=1):
            for pattern in weak_crypto_patterns:
                if pattern.search(line):
                    issues.append({
                        "line": line_num,
                        "message": "Weak cryptographic algorithm used",
                        "fix": "Use a stronger cryptographic algorithm such as SHA-256.",
                        "severity": "high"
                    })
        return issues

    def check_hardcoded_ips(self):
        issues = []
        ip_pattern = re.compile(r'\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b')
        for line_num, line in enumerate(self.code.split('\n'), start=1):
            if ip_pattern.search(line):
                issues.append({
                    "line": line_num,
                    "message": "Hardcoded IP address found",
                    "fix": "Avoid hardcoding IP addresses or configure them through environment variables.",
                    "severity": "medium"
                })
        return issues

    def check_deprecated_libraries(self):
        issues = []
        deprecated_libraries = ["crypto"]
        for line_num, line in enumerate(self.code.split('\n'), start=1):
            for lib in deprecated_libraries:
                if f"require('{lib}')" in line or f'import {lib}' in line:
                    issues.append({
                        "line": line_num,
                        "message": f"Deprecated library '{lib}' used",
                        "fix": f"Use an alternative library that is actively maintained.",
                        "severity": "medium"
                    })
        return issues

    def check_insecure_http_urls(self):
        issues = []
        http_url_pattern = re.compile(r'\bhttp://[^\s]+')
        for line_num, line in enumerate(self.code.split('\n'), start=1):
            if http_url_pattern.search(line):
                issues.append({
                    "line": line_num,
                    "message": "Insecure HTTP URL found",
                    "fix": "Use HTTPS URLs instead of HTTP URLs.",
                    "severity": "medium"
                })
        return issues

    def check_ineffective_security_headers(self):
        issues = []
        ineffective_headers = ['X-XSS-Protection: 0', 'Content-Security-Policy: unsafe-inline']
        for line_num, line in enumerate(self.code.split('\n'), start=1):
            for header in ineffective_headers:
                if header in line:
                    issues.append({
                        "line": line_num,
                        "message": f"Ineffective security header used: {header}",
                        "fix": "Remove or update the security header to a more secure value.",
                        "severity": "medium"
                    })
        return issues

    def check_inner_html_usage(self):
        issues = []
        for line_num, line in enumerate(self.code.split('\n'), start=1):
            if "innerHTML" in line:
                issues.append({
                    "line": line_num,
                    "message": "Use of innerHTML detected",
                    "fix": "Avoid using innerHTML and use safer methods such as textContent.",
                    "severity": "high"
                })
        return issues

    def check_insecure_event_handlers(self):
        issues = []
        insecure_event_patterns = [re.compile(r'on\w+=".+?"')]
        for line_num, line in enumerate(self.code.split('\n'), start=1):
            for pattern in insecure_event_patterns:
                if pattern.search(line):
                    issues.append({
                        "line": line_num,
                        "message": "Inline event handler detected",
                        "fix": "Avoid using inline event handlers to mitigate potential XSS attacks.",
                        "severity": "high"
                    })
        return issues