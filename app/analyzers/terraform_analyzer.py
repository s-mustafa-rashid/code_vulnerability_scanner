import re
import json

class BaseAnalyzer:
    SEVERITY_WEIGHTS = {
        "critical": 20,
        "high": 10,
        "medium": 5,
        "low": 2
    }
    
    def calculate_score(self, issues):
        base_score = 100
        total_penalty = sum([self.SEVERITY_WEIGHTS[issue["severity"]] for issue in issues])
        total_penalty = min(total_penalty, base_score)  # Cap the penalty to the base score
        return max(0, base_score - total_penalty)

class TerraformAnalyzer(BaseAnalyzer):
    def __init__(self, code):
        self.code = code.replace('\r\n', '\n').replace('\r', '\n')

    def analyze(self):
        issues = []
        issues.extend(self.check_hardcoded_secrets())
        issues.extend(self.check_insecure_security_groups())
        issues.extend(self.check_unencrypted_storage())
        issues.extend(self.check_insecure_s3_acls())
        issues.extend(self.check_insecure_iam_policies())
        issues.extend(self.check_open_security_group_ports())
        issues.extend(self.check_iam_root_user_usage())
        issues.extend(self.check_unrestricted_egress_rules())
        issues.extend(self.check_publicly_accessible_rds_instances())
        issues.extend(self.check_plaintext_secrets_in_variables())
        issues.extend(self.check_missing_mfa_in_policies())
        score = self.calculate_score(issues)
        return {"score": score, "issues": issues}

    def check_hardcoded_secrets(self):
        issues = []
        secret_patterns = {
            "AWS Access Key": re.compile(r'AKIA[0-9A-Z]{16}'),
            "AWS Secret Key": re.compile(r'aws_secret_key\s*=\s*["\'][A-Za-z0-9/+=]{40}["\']'),
            "Generic Secret": re.compile(r'secret\s*=\s*["\'][^"\']+["\']')
        }

        for line_num, line in enumerate(self.code.split('\n'), start=1):
            for secret_name, pattern in secret_patterns.items():
                if pattern.search(line):
                    issues.append({
                        "line": line_num,
                        "message": f"Possible hardcoded {secret_name} found",
                        "fix": "Store secrets in environment variables or configuration files.",
                        "severity": "high"
                    })
        return issues

    def check_insecure_security_groups(self):
        issues = []
        insecure_sg_patterns = [
            re.compile(r'cidr_blocks\s*=\s*\["0.0.0.0/0"\]', re.IGNORECASE)
        ]

        for line_num, line in enumerate(self.code.split('\n'), start=1):
            for pattern in insecure_sg_patterns:
                if pattern.search(line):
                    issues.append({
                        "line": line_num,
                        "message": "Insecure security group rule found: allows access from all IPs",
                        "fix": "Restrict access to specific IPs or ranges.",
                        "severity": "critical"
                    })
        return issues

    def check_unencrypted_storage(self):
        issues = []
        unencrypted_storage_patterns = [
            re.compile(r'encrypted\s*=\s*false', re.IGNORECASE)
        ]

        for line_num, line in enumerate(self.code.split('\n'), start=1):
            for pattern in unencrypted_storage_patterns:
                if pattern.search(line):
                    issues.append({
                        "line": line_num,
                        "message": "Unencrypted storage found",
                        "fix": "Enable encryption for storage resources.",
                        "severity": "high"
                    })
        return issues

    def check_insecure_s3_acls(self):
        issues = []
        insecure_acl_patterns = [
            re.compile(r'acl\s*=\s*["\']public-read["\']', re.IGNORECASE),
            re.compile(r'acl\s*=\s*["\']public-read-write["\']', re.IGNORECASE)
        ]

        for line_num, line in enumerate(self.code.split('\n'), start=1):
            for pattern in insecure_acl_patterns:
                if pattern.search(line):
                    issues.append({
                        "line": line_num,
                        "message": "Insecure S3 bucket ACL found",
                        "fix": "Use private ACLs for S3 buckets or configure bucket policies for specific access.",
                        "severity": "high"
                    })
        return issues

    def check_insecure_iam_policies(self):
        issues = []
        policy_pattern = re.compile(r'policy\s*=\s*jsonencode\((.*?)\)', re.DOTALL)

        for match in policy_pattern.finditer(self.code):
            block = match.group(1)
            start_line = self.code[:match.start()].count('\n') + 1

            try:
                policy = json.loads(block.strip())
            except json.JSONDecodeError:
                continue

            flagged_effect = False
            flagged_action = False
            flagged_resource = False

            for statement in policy.get("Statement", []):
                if statement.get("Effect") == "Allow" and not flagged_effect:
                    issues.append({
                        "line": start_line,
                        "message": "Overly permissive IAM policy found",
                        "fix": "Restrict IAM policies to least privilege needed for the tasks.",
                        "severity": "high"
                    })
                    flagged_effect = True
                if isinstance(statement.get("Action"), list) and "*" in statement.get("Action") and not flagged_action:
                    issues.append({
                        "line": start_line,
                        "message": "Overly permissive IAM policy found",
                        "fix": "Restrict IAM policies to least privilege needed for the tasks.",
                        "severity": "high"
                    })
                    flagged_action = True
                if isinstance(statement.get("Resource"), list) and "*" in statement.get("Resource") and not flagged_resource:
                    issues.append({
                        "line": start_line,
                        "message": "Overly permissive IAM policy found",
                        "fix": "Restrict IAM policies to least privilege needed for the tasks.",
                        "severity": "high"
                    })
                    flagged_resource = True

        return issues

    def check_open_security_group_ports(self):
        issues = []
        port_patterns = [
            re.compile(r'from_port\s*=\s*22', re.IGNORECASE),  # SSH
            re.compile(r'from_port\s*=\s*3306', re.IGNORECASE),  # MySQL
            re.compile(r'from_port\s*=\s*5432', re.IGNORECASE)  # PostgreSQL
        ]

        for line_num, line in enumerate(self.code.split('\n'), start=1):
            for pattern in port_patterns:
                if pattern.search(line):
                    cidr_blocks_line = next((ln for ln in self.code.split('\n')[line_num - 1:line_num + 2] if 'cidr_blocks' in ln), "")
                    if '0.0.0.0/0' in cidr_blocks_line:
                        issues.append({
                            "line": line_num,
                            "message": "Open port found allowing unrestricted access",
                            "fix": "Restrict access to specific IPs or ranges.",
                            "severity": "critical"
                        })
        return issues

    def check_iam_root_user_usage(self):
        issues = []
        root_user_pattern = re.compile(r'arn:aws:iam::[0-9]{12}:root', re.IGNORECASE)
        for line_num, line in enumerate(self.code.split('\n'), start=1):
            if root_user_pattern.search(line):
                issues.append({
                    "line": line_num,
                    "message": "IAM policy allows root user access",
                    "fix": "Remove root user access from IAM policies and use specific roles.",
                    "severity": "critical"
                })
        return issues

    def check_unrestricted_egress_rules(self):
        issues = []
        unrestricted_egress_pattern = re.compile(r'egress\ {(.|\n)*cidr_blocks\s*=\s*\["0.0.0.0/0"\]', re.IGNORECASE | re.MULTILINE)
        for match in unrestricted_egress_pattern.finditer(self.code):
            start_line = self.code[:match.start()].count('\n') + 1
            issues.append({
                "line": start_line,
                "message": "Unrestricted egress rule found",
                "fix": "Restrict egress traffic to specific IPs or ranges.",
                "severity": "high"
            })
        return issues

    def check_publicly_accessible_rds_instances(self):
        issues = []
        public_rds_pattern = re.compile(r'publicly_accessible\s*=\s*true', re.IGNORECASE)
        for line_num, line in enumerate(self.code.split('\n'), start=1):
            if public_rds_pattern.search(line):
                issues.append({
                    "line": line_num,
                    "message": "Publicly accessible RDS instance found",
                    "fix": "Set publicly_accessible to false for RDS instances.",
                    "severity": "high"
                })
        return issues

    def check_plaintext_secrets_in_variables(self):
        issues = []
        sensitive_var_pattern = re.compile(r'variable\s+["\'](.*?)["\']\s+{\s*type\s+=\s+(.*?)\s+default\s+=\s+["\'](.*?)["\']', re.DOTALL | re.IGNORECASE)
        for match in sensitive_var_pattern.finditer(self.code):
            var_name = match.group(1)
            start_line = self.code[:match.start()].count('\n') + 1
            issues.append({
                "line": start_line,
                "message": f"Plaintext secret found in Terraform variable: {var_name}",
                "fix": "Store sensitive values in environment variables or use the 'sensitive' attribute.",
                "severity": "high"
            })

        value_regex = re.compile(r'default\s*=\\s*["\'][^"\']+["\']', re.IGNORECASE)
        for line_num, line in enumerate(self.code.split('\n'), start=1):
            if value_regex.search(line):
                issues.append({
                    "line": line_num,
                    "message": "Plaintext value found in Terraform variable",
                    "fix": "Store sensitive values in environment variables or use the 'sensitive' attribute.",
                    "severity": "high"
                })
        return issues

    def check_missing_mfa_in_policies(self):
        issues = []
        policy_pattern = re.compile(r'policy\s*=\s*jsonencode\((.*?)\)', re.DOTALL)

        for match in policy_pattern.finditer(self.code):
            block = match.group(1)
            start_line = self.code[:match.start()].count('\n') + 1

            try:
                policy = json.loads(block.strip())
            except json.JSONDecodeError:
                continue

            for statement in policy.get("Statement", []):
                if not statement.get("Condition"):
                    issues.append({
                        "line": start_line,
                        "message": "IAM policy missing MFA requirement",
                        "fix": "Add MFA conditions to IAM policies.",
                        "severity": "high"
                    })
                    break

        return issues