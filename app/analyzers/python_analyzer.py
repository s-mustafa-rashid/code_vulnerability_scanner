import re
import ast

class BaseAnalyzer:
    SEVERITY_WEIGHTS = {
        "critical": 20,
        "high": 10,
        "medium": 5,
        "low": 2
    }

    def calculate_score(self, issues):
        base_score = 100
        total_penalty = sum([self.SEVERITY_WEIGHTS[issue["severity"]] for issue in issues])
        total_penalty = min(total_penalty, base_score)  # Cap the penalty to the base score
        return max(0, base_score - total_penalty)

class PythonAnalyzer(BaseAnalyzer):
    def __init__(self, code):
        self.code = code

    def analyze(self):
        issues = []
        issues.extend(self.check_hardcoded_secrets())
        issues.extend(self.check_command_injection())
        issues.extend(self.check_insecure_functions())
        issues.extend(self.check_weak_cryptography())
        issues.extend(self.check_hardcoded_ips())
        issues.extend(self.check_deprecated_functions())
        issues.extend(self.check_insecure_file_permissions())
        issues.extend(self.check_insecure_deserialization())
        issues.extend(self.check_use_of_eval())
        issues.extend(self.check_malicious_code())
        score = self.calculate_score(issues)
        return {"score": score, "issues": issues}

    def check_hardcoded_secrets(self):
        issues = []
        secret_patterns = {
            "AWS Access Key": re.compile(r'AKIA[0-9A-Z]{16}'),
            "AWS Secret Key": re.compile(r'aws_secret_access_key\s*=\s*["\'][A-Za-z0-9/+=]{40}["\']'),
            "Generic Secret": re.compile(r'secret\s*=\s*["\'][^"\']+["\']')
        }

        for line_num, line in enumerate(self.code.split('\n'), start=1):
            for secret_name, pattern in secret_patterns.items():
                if pattern.search(line):
                    issues.append({
                        "line": line_num,
                        "message": f"Possible hardcoded {secret_name} found",
                        "fix": "Store secrets in environment variables or configuration files.",
                        "severity": "high"
                    })
        return issues

    def check_command_injection(self):
        issues = []
        for node in ast.walk(ast.parse(self.code)):
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):
                if node.func.attr in ["system", "popen"]:
                    issues.append({
                        "line": node.lineno,
                        "message": "Insecure use of system or popen function",
                        "fix": "Avoid using system or popen functions or sanitize inputs properly.",
                        "severity": "critical"
                    })
        return issues

    def check_insecure_functions(self):
        issues = []
        for node in ast.walk(ast.parse(self.code)):
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name):
                if node.func.id in ["eval", "exec"]:
                    issues.append({
                        "line": node.lineno,
                        "message": f"Usage of insecure function {node.func.id}",
                        "fix": f"Avoid using {node.func.id} function or sanitize inputs properly.",
                        "severity": "high"
                    })
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):
                if node.func.attr == "call" and any(kw.arg == 'shell' and kw.value.value == True for kw in node.keywords):
                    issues.append({
                        "line": node.lineno,
                        "message": "Insecure use of subprocess with shell=True",
                        "fix": "Avoid using shell=True or sanitize the input to avoid command injection.",
                        "severity": "critical"
                    })
        return issues

    def check_weak_cryptography(self):
        issues = []
        for node in ast.walk(ast.parse(self.code)):
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):
                if node.func.attr in ["md5", "sha1"]:
                    issues.append({
                        "line": node.lineno,
                        "message": f"Weak cryptographic algorithm {node.func.attr} used",
                        "fix": "Use a stronger cryptographic algorithm such as SHA-256.",
                        "severity": "high"
                    })
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):
                if node.func.attr == "choice" and isinstance(node.func.value, ast.Name) and node.func.value.id == "random":
                    issues.append({
                        "line": node.lineno,
                        "message": "Use of random module for cryptographic purposes",
                        "fix": "Use the secrets module for generating secure tokens.",
                        "severity": "high"
                    })
        return issues

    def check_hardcoded_ips(self):
        issues = []
        ip_pattern = re.compile(r'\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b')
        for line_num, line in enumerate(self.code.split('\n'), start=1):
            if ip_pattern.search(line):
                issues.append({
                    "line": line_num,
                    "message": "Hardcoded IP address found",
                    "fix": "Avoid hardcoding IP addresses or configure them through environment variables.",
                    "severity": "medium"
                })
        return issues

    def check_deprecated_functions(self):
        issues = []
        for node in ast.walk(ast.parse(self.code)):
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):
                if node.func.attr == "escape" and isinstance(node.func.value, ast.Name) and node.func.value.id == "cgi":
                    issues.append({
                        "line": node.lineno,
                        "message": "Use of deprecated function cgi.escape",
                        "fix": "Use html.escape from the html module instead.",
                        "severity": "medium"
                    })
        return issues

    def check_insecure_file_permissions(self):
        issues = []
        for node in ast.walk(ast.parse(self.code)):
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):
                if node.func.attr == "chmod":
                    for arg in node.args:
                        if isinstance(arg, ast.Constant) and arg.value == 0o777:
                            issues.append({
                                "line": node.lineno,
                                "message": "Insecure file permissions set with os.chmod",
                                "fix": "Set more restrictive file permissions, such as 0o600.",
                                "severity": "high"
                            })
        return issues

    def check_insecure_deserialization(self):
        issues = []
        for node in ast.walk(ast.parse(self.code)):
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):
                if node.func.attr == "loads" and isinstance(node.func.value, ast.Name) and node.func.value.id == "pickle":
                    issues.append({
                        "line": node.lineno,
                        "message": "Usage of insecure function pickle.loads",
                        "fix": "Avoid using insecure functions. Use safer alternatives or validate inputs thoroughly.",
                        "severity": "critical"
                    })
        return issues

    def check_use_of_eval(self):
        issues = []
        for node in ast.walk(ast.parse(self.code)):
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name):
                if node.func.id == "eval":
                    issues.append({
                        "line": node.lineno,
                        "message": "Usage of eval function",
                        "fix": "Avoid using eval function or sanitize inputs properly.",
                        "severity": "high"
                    })
        return issues

    def check_malicious_code(self):
        issues = []
        # Example pattern for detecting malicious code
        malicious_patterns = [
            re.compile(r'exec\(.*\)'),  # Usage of exec
            re.compile(r'subprocess\.Popen\(.*\)'),  # Potential malicious subprocess usage
            re.compile(r'(base64|binascii)\.b64decode\(.*\)'),  # Decoding base64, potential exfiltration
            re.compile(r'socket\.socket\(.*\)'),  # Creating a socket, potential for unauthorized network access
        ]

        for line_num, line in enumerate(self.code.split('\n'), start=1):
            for pattern in malicious_patterns:
                if pattern.search(line):
                    issues.append({
                        "line": line_num,
                        "message": "Potential malicious code detected",
                        "fix": "Review the usage of potentially dangerous functions and ensure they are necessary and safe.",
                        "severity": "critical"
                    })
        return issues