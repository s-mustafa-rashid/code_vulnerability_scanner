import re
import json

class TerraformAnalyzer:
    def __init__(self, code):
        self.code = code.replace('\r\n', '\n').replace('\r', '\n')

    def analyze(self):
        issues = []
        issues.extend(self.check_hardcoded_secrets())
        issues.extend(self.check_insecure_security_groups())
        issues.extend(self.check_unencrypted_storage())
        issues.extend(self.check_insecure_s3_acls())
        issues.extend(self.check_insecure_iam_policies())
        score = max(0, 100 - len(issues) * 5)
        return {"score": score, "issues": issues}

    def check_hardcoded_secrets(self):
        issues = []
        secret_patterns = {
            "AWS Access Key": re.compile(r'AKIA[0-9A-Z]{16}'),
            "AWS Secret Key": re.compile(r'aws_secret_key\s*=\s*["\'][A-Za-z0-9/+=]{40}["\']'),
            "Generic Secret": re.compile(r'secret\s*=\s*["\'][^"\']+["\']')
        }

        for line_num, line in enumerate(self.code.split('\n'), start=1):
            for secret_name, pattern in secret_patterns.items():
                if pattern.search(line):
                    issues.append({
                        "line": line_num,
                        "message": f"Possible hardcoded {secret_name} found",
                        "fix": "Store secrets in environment variables or configuration files."
                    })
        return issues

    def check_insecure_security_groups(self):
        issues = []
        insecure_sg_patterns = [
            re.compile(r'cidr_blocks\s*=\s*\["0.0.0.0/0"\]', re.IGNORECASE)
        ]

        for line_num, line in enumerate(self.code.split('\n'), start=1):
            for pattern in insecure_sg_patterns:
                if pattern.search(line):
                    issues.append({
                        "line": line_num,
                        "message": "Insecure security group rule found: allows access from all IPs",
                        "fix": "Restrict access to specific IPs or ranges."
                    })
        return issues

    def check_unencrypted_storage(self):
        issues = []
        unencrypted_storage_patterns = [
            re.compile(r'encrypted\s*=\s*false', re.IGNORECASE)
        ]

        for line_num, line in enumerate(self.code.split('\n'), start=1):
            for pattern in unencrypted_storage_patterns:
                if pattern.search(line):
                    issues.append({
                        "line": line_num,
                        "message": "Unencrypted storage found",
                        "fix": "Enable encryption for storage resources."
                    })
        return issues

    def check_insecure_s3_acls(self):
        issues = []
        insecure_acl_patterns = [
            re.compile(r'acl\s*=\s*["\']public-read["\']', re.IGNORECASE),
            re.compile(r'acl\s*=\s*["\']public-read-write["\']', re.IGNORECASE)
        ]

        for line_num, line in enumerate(self.code.split('\n'), start=1):
            for pattern in insecure_acl_patterns:
                if pattern.search(line):
                    issues.append({
                        "line": line_num,
                        "message": "Insecure S3 bucket ACL found",
                        "fix": "Use private ACLs for S3 buckets or configure bucket policies for specific access."
                    })
        return issues

    def check_insecure_iam_policies(self):
        issues = []
        policy_pattern = re.compile(r'policy\s*=\s*jsonencode\((.*?)\)', re.DOTALL)

        for match in policy_pattern.finditer(self.code):
            block = match.group(1)
            start_line = self.code[:match.start()].count('\n') + 1

            try:
                policy = json.loads(block.strip())
            except json.JSONDecodeError:
                continue

            flagged_effect = False
            flagged_action = False
            flagged_resource = False

            for statement in policy.get("Statement", []):
                if statement.get("Effect") == "Allow" and not flagged_effect:
                    issues.append({
                        "line": start_line,
                        "message": "Overly permissive IAM policy found",
                        "fix": "Restrict IAM policies to least privilege needed for the tasks."
                    })
                    flagged_effect = True
                if isinstance(statement.get("Action"), list) and "*" in statement.get("Action") and not flagged_action:
                    issues.append({
                        "line": start_line,
                        "message": "Overly permissive IAM policy found",
                        "fix": "Restrict IAM policies to least privilege needed for the tasks."
                    })
                    flagged_action = True
                if isinstance(statement.get("Resource"), list) and "*" in statement.get("Resource") and not flagged_resource:
                    issues.append({
                        "line": start_line,
                        "message": "Overly permissive IAM policy found",
                        "fix": "Restrict IAM policies to least privilege needed for the tasks."
                    })
                    flagged_resource = True

        return issues
