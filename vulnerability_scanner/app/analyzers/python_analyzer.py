from flask import Flask, request, jsonify, render_template
import os
import re  # Import the re module for regular expressions
import ast  # Import the ast module for abstract syntax tree operations

app = Flask(__name__)

class PythonAnalyzer:
    def __init__(self, code):
        self.code = code

    def analyze(self):
        issues = []
        issues.extend(self.check_hardcoded_secrets())
        issues.extend(self.check_command_injection())
        issues.extend(self.check_insecure_functions())
        issues.extend(self.check_weak_cryptography())
        issues.extend(self.check_hardcoded_ips())
        issues.extend(self.check_deprecated_functions())
        issues.extend(self.check_insecure_file_permissions())
        issues.extend(self.check_insecure_deserialization())
        issues.extend(self.check_use_of_eval())
        issues.extend(self.check_malicious_code())
        score = max(0, 100 - len(issues) * 5)
        return {"score": score, "issues": issues}

    def check_hardcoded_secrets(self):
        issues = []
        secret_patterns = {
            "AWS Access Key": re.compile(r'AKIA[0-9A-Z]{16}'),
            "AWS Secret Key": re.compile(r'aws_secret_access_key\s*=\s*["\'][A-Za-z0-9/+=]{40}["\']'),
            "Generic Secret": re.compile(r'secret\s*=\s*["\'][^"\']+["\']')
        }

        for line_num, line in enumerate(self.code.split('\n'), start=1):
            for secret_name, pattern in secret_patterns.items():
                if pattern.search(line):
                    issues.append({
                        "line": line_num,
                        "message": f"Possible hardcoded {secret_name} found",
                        "fix": "Store secrets in environment variables or configuration files."
                    })
        return issues

    def check_command_injection(self):
        issues = []
        for node in ast.walk(ast.parse(self.code)):
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):
                if node.func.attr in ["system", "popen"]:
                    issues.append({
                        "line": node.lineno,
                        "message": "Insecure use of system or popen function",
                        "fix": "Avoid using system or popen functions or sanitize inputs properly."
                    })
        return issues

    def check_insecure_functions(self):
        issues = []
        for node in ast.walk(ast.parse(self.code)):
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name):
                if node.func.id in ["eval", "exec"]:
                    issues.append({
                        "line": node.lineno,
                        "message": f"Usage of insecure function {node.func.id}",
                        "fix": f"Avoid using {node.func.id} function or sanitize inputs properly."
                    })
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):
                if node.func.attr == "call" and any(kw.arg == 'shell' and kw.value.value == True for kw in node.keywords):
                    issues.append({
                        "line": node.lineno,
                        "message": "Insecure use of subprocess with shell=True",
                        "fix": "Avoid using shell=True or sanitize the input to avoid command injection."
                    })
        return issues

    def check_weak_cryptography(self):
        issues = []
        for node in ast.walk(ast.parse(self.code)):
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):
                if node.func.attr in ["md5", "sha1"]:
                    issues.append({
                        "line": node.lineno,
                        "message": f"Weak cryptographic algorithm {node.func.attr} used",
                        "fix": "Use a stronger cryptographic algorithm such as SHA-256."
                    })
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):
                if node.func.attr == "choice" and isinstance(node.func.value, ast.Name) and node.func.value.id == "random":
                    issues.append({
                        "line": node.lineno,
                        "message": "Use of random module for cryptographic purposes",
                        "fix": "Use the secrets module for generating secure tokens."
                    })
        return issues

    def check_hardcoded_ips(self):
        issues = []
        ip_pattern = re.compile(r'\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b')
        for line_num, line in enumerate(self.code.split('\n'), start=1):
            if ip_pattern.search(line):
                issues.append({
                    "line": line_num,
                    "message": "Hardcoded IP address found",
                    "fix": "Avoid hardcoding IP addresses or configure them through environment variables."
                })
        return issues

    def check_deprecated_functions(self):
        issues = []
        for node in ast.walk(ast.parse(self.code)):
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):
                if node.func.attr == "escape" and isinstance(node.func.value, ast.Name) and node.func.value.id == "cgi":
                    issues.append({
                        "line": node.lineno,
                        "message": "Use of deprecated function cgi.escape",
                        "fix": "Use html.escape from the html module instead."
                    })
        return issues

    def check_insecure_file_permissions(self):
        issues = []
        for node in ast.walk(ast.parse(self.code)):
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):
                if node.func.attr == "chmod":
                    for arg in node.args:
                        if isinstance(arg, ast.Constant) and arg.value == 0o777:
                            issues.append({
                                "line": node.lineno,
                                "message": "Insecure file permissions set with os.chmod",
                                "fix": "Set more restrictive file permissions, such as 0o600."
                            })
        return issues

    def check_insecure_deserialization(self):
        issues = []
        for node in ast.walk(ast.parse(self.code)):
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):
                if node.func.attr == "loads" and isinstance(node.func.value, ast.Name) and node.func.value.id == "pickle":
                    issues.append({
                        "line": node.lineno,
                        "message": "Usage of insecure function pickle.loads",
                        "fix": "Avoid using insecure functions. Use safer alternatives or validate inputs thoroughly."
                    })
        return issues

    def check_use_of_eval(self):
        issues = []
        for node in ast.walk(ast.parse(self.code)):
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name):
                if node.func.id == "eval":
                    issues.append({
                        "line": node.lineno,
                        "message": "Usage of eval function",
                        "fix": "Avoid using eval function or sanitize inputs properly."
                    })
        return issues

    def check_malicious_code(self):
        issues = []
        # Example pattern for detecting malicious code
        malicious_patterns = [
            re.compile(r'exec\(.*\)'),  # Usage of exec
            re.compile(r'subprocess\.Popen\(.*\)'),  # Potential malicious subprocess usage
            re.compile(r'(base64|binascii)\.b64decode\(.*\)'),  # Decoding base64, potential exfiltration
            re.compile(r'socket\.socket\(.*\)'),  # Creating a socket, potential for unauthorized network access
        ]

        for line_num, line in enumerate(self.code.split('\n'), start=1):
            for pattern in malicious_patterns:
                if pattern.search(line):
                    issues.append({
                        "line": line_num,
                        "message": "Potential malicious code detected",
                        "fix": "Review the usage of potentially dangerous functions and ensure they are necessary and safe."
                    })
        return issues

def analyze_code(file_path):
    with open(file_path, 'r') as file:
        code = file.read()

    analyzer = PythonAnalyzer(code)
    result = analyzer.analyze()

    return result["issues"], result["score"]

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/analyze', methods=['POST'])
def analyze():
    if 'file' not in request.files:
        return jsonify({"error": "No file part"})
    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No selected file"})
    if file:
        filename = file.filename
        file_path = os.path.join('uploads', filename)
        file.save(file_path)
        issues, score = analyze_code(file_path)
        return jsonify({"issues": issues, "score": score})

if __name__ == '__main__':
    app.run(debug=True)
