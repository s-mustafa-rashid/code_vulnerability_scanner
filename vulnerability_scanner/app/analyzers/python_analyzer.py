import re
import ast

class BaseAnalyzer:
    SEVERITY_WEIGHTS = {
        "critical": 20,
        "high": 10,
        "medium": 5,
        "low": 2
    }

    def calculate_score(self, issues):
        base_score = 100
        total_penalty = sum([self.SEVERITY_WEIGHTS[issue["severity"]] for issue in issues])
        total_penalty = min(total_penalty, base_score)  # Cap the penalty to the base score
        return max(0, base_score - total_penalty)

class PythonAnalyzer(BaseAnalyzer):
    def __init__(self, code):
        self.code = code

    def analyze(self):
        issues = []
        detections = set()  # To keep track of detected issues and avoid duplicates

        issues.extend(self.check_hardcoded_secrets(detections))
        issues.extend(self.check_command_injection(detections))
        issues.extend(self.check_insecure_functions(detections))
        issues.extend(self.check_weak_cryptography(detections))
        issues.extend(self.check_hardcoded_ips(detections))
        issues.extend(self.check_deprecated_functions(detections))
        issues.extend(self.check_insecure_file_permissions(detections))
        issues.extend(self.check_insecure_deserialization(detections))
        issues.extend(self.check_malicious_code(detections))
        issues.extend(self.check_sql_injection(detections))
        issues.extend(self.check_insecure_http_requests(detections))
        
        score = self.calculate_score(issues)
        return {"score": score, "issues": issues}

    def add_issue_if_new(self, issues, detections, line, message, fix, severity):
        detection_key = (line, message)
        if detection_key not in detections:
            issues.append({
                "line": line,
                "message": message,
                "fix": fix,
                "severity": severity
            })
            detections.add(detection_key)

    def check_hardcoded_secrets(self, detections):
        issues = []
        secret_patterns = {
            "AWS Access Key": re.compile(r'AKIA[0-9A-Z]{16}'),
            "AWS Secret Key": re.compile(r'aws_secret_access_key\s*=\s*["\'][A-Za-z0-9/+=]{40}["\']'),
            "Generic Secret": re.compile(r'secret\s*=\s*["\'][^"\']+["\']')
        }

        for line_num, line in enumerate(self.code.split('\n'), start=1):
            for secret_name, pattern in secret_patterns.items():
                if pattern.search(line):
                    self.add_issue_if_new(
                        issues, detections, line_num, 
                        f"Possible hardcoded {secret_name} found", 
                        "Store secrets in environment variables or configuration files.", 
                        "high"
                    )
        return issues

    def check_command_injection(self, detections):
        issues = []
        for node in ast.walk(ast.parse(self.code)):
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):
                if node.func.attr in ["system", "popen"]:
                    self.add_issue_if_new(
                        issues, detections, node.lineno,
                        "Insecure use of system or popen function",
                        "Avoid using system or popen functions or sanitize inputs properly.",
                        "critical"
                    )
        return issues

    def check_insecure_functions(self, detections):
        issues = []
        for node in ast.walk(ast.parse(self.code)):
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Name):
                if node.func.id in ["eval", "exec"]:
                    self.add_issue_if_new(
                        issues, detections, node.lineno,
                        f"Usage of insecure function {node.func.id}",
                        f"Avoid using {node.func.id} function or sanitize inputs properly.",
                        "high"
                    )
                
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):
                if node.func.attr == "call" and any(kw.arg == 'shell' and kw.value.value == True for kw in node.keywords):
                    self.add_issue_if_new(
                        issues, detections, node.lineno,
                        "Insecure use of subprocess with shell=True",
                        "Avoid using shell=True or sanitize the input to avoid command injection.",
                        "critical"
                    )
        return issues

    def check_weak_cryptography(self, detections):
        issues = []
        for node in ast.walk(ast.parse(self.code)):
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):
                if node.func.attr in ["md5", "sha1"]:
                    self.add_issue_if_new(
                        issues, detections, node.lineno,
                        f"Weak cryptographic algorithm {node.func.attr} used",
                        "Use a stronger cryptographic algorithm such as SHA-256.",
                        "high"
                    )
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):
                if node.func.attr == "choice" and isinstance(node.func.value, ast.Name) and node.func.value.id == "random":
                    self.add_issue_if_new(
                        issues, detections, node.lineno,
                        "Use of random module for cryptographic purposes",
                        "Use the secrets module for generating secure tokens.",
                        "high"
                    )
        return issues

    def check_hardcoded_ips(self, detections):
        issues = []
        ip_pattern = re.compile(r'\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b')
        for line_num, line in enumerate(self.code.split('\n'), start=1):
            if ip_pattern.search(line):
                self.add_issue_if_new(
                    issues, detections, line_num,
                    "Hardcoded IP address found",
                    "Avoid hardcoding IP addresses or configure them through environment variables.",
                    "medium"
                )
        return issues

    def check_deprecated_functions(self, detections):
        issues = []
        for node in ast.walk(ast.parse(self.code)):
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):
                if node.func.attr == "escape" and isinstance(node.func.value, ast.Name) and node.func.value.id == "cgi":
                    self.add_issue_if_new(
                        issues, detections, node.lineno,
                        "Use of deprecated function cgi.escape",
                        "Use html.escape from the html module instead.",
                        "medium"
                    )
        return issues

    def check_insecure_file_permissions(self, detections):
        issues = []
        for node in ast.walk(ast.parse(self.code)):
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):
                if node.func.attr == "chmod":
                    for arg in node.args:
                        if isinstance(arg, ast.Constant) and arg.value == 0o777:
                            self.add_issue_if_new(
                                issues, detections, node.lineno,
                                "Insecure file permissions set with os.chmod",
                                "Set more restrictive file permissions, such as 0o600.",
                                "high"
                            )
        return issues

    def check_insecure_deserialization(self, detections):
        issues = []
        for node in ast.walk(ast.parse(self.code)):
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):
                if node.func.attr == "loads" and isinstance(node.func.value, ast.Name) and node.func.value.id == "pickle":
                    self.add_issue_if_new(
                        issues, detections, node.lineno,
                        "Usage of insecure function pickle.loads",
                        "Avoid using insecure functions. Use safer alternatives or validate inputs thoroughly.",
                        "critical"
                    )
        return issues

    def check_malicious_code(self, detections):
        issues = []
        # Example pattern for detecting malicious code
        malicious_patterns = [
            re.compile(r'exec\(.*\)'),  # Usage of exec
            re.compile(r'subprocess\.Popen\(.*\)'),  # Potential malicious subprocess usage
            re.compile(r'(base64|binascii)\.b64decode\(.*\)'),  # Decoding base64, potential exfiltration
            re.compile(r'socket\.socket\(.*\)'),  # Creating a socket, potential for unauthorized network access
        ]

        for line_num, line in enumerate(self.code.split('\n'), start=1):
            for pattern in malicious_patterns:
                if pattern.search(line):
                    self.add_issue_if_new(
                        issues, detections, line_num,
                        "Potential malicious code detected",
                        "Review the usage of potentially dangerous functions and ensure they are necessary and safe.",
                        "critical"
                    )
        return issues

    def check_sql_injection(self, detections):
        issues = []
        for node in ast.walk(ast.parse(self.code)):
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):
                if node.func.attr in ["execute"]:
                    if isinstance(node.args[0], (ast.BinOp, ast.FormattedValue, ast.JoinedStr)):
                        self.add_issue_if_new(
                            issues, detections, node.lineno,
                            "Potential SQL injection vulnerability",
                            "Use parameterized queries to prevent SQL injection.",
                            "critical"
                        )
        return issues
    
    def check_insecure_http_requests(self, detections):
        issues = []
        for node in ast.walk(ast.parse(self.code)):
            if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):
                if node.func.attr in ["get", "post", "put", "delete", "patch", "head", "options"]:
                    for kw in node.keywords:
                        if kw.arg == "verify" and isinstance(kw.value, ast.Constant) and kw.value.value == False:
                            self.add_issue_if_new(
                                issues, detections, node.lineno,
                                "Insecure HTTP request with certificate verification turned off",
                                "Set 'verify=True' or ensure the SSL certificate is properly verified.",
                                "high"
                            )
        return issues
