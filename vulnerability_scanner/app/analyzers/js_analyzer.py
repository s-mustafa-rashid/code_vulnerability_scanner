import re

class JavaScriptAnalyzer:
    def __init__(self, code):
        self.code = code

    def analyze(self):
        issues = []
        issues.extend(self.check_hardcoded_secrets())
        issues.extend(self.check_use_of_eval())
        issues.extend(self.check_document_write())
        issues.extend(self.check_weak_crypto())
        issues.extend(self.check_hardcoded_ips())
        issues.extend(self.check_deprecated_libraries())
        score = max(0, 100 - len(issues) * 5)
        return {"score": score, "issues": issues}

    def check_hardcoded_secrets(self):
        issues = []
        secret_patterns = {
            "API Key": re.compile(r'["\'][A-Za-z0-9_\-]{35,}["\']'),
            "Password": re.compile(r'["\'][^"\']*password[^"\']*["\']', re.IGNORECASE)
        }

        for line_num, line in enumerate(self.code.split('\n'), start=1):
            for secret_name, pattern in secret_patterns.items():
                if pattern.search(line):
                    issues.append({
                        "line": line_num,
                        "message": f"Possible hardcoded {secret_name} found",
                        "fix": "Store secrets in environment variables or configuration files."
                    })
        return issues

    def check_use_of_eval(self):
        issues = []
        for line_num, line in enumerate(self.code.split('\n'), start=1):
            if "eval(" in line:
                issues.append({
                    "line": line_num,
                    "message": "Use of eval function found",
                    "fix": "Avoid using eval function or sanitize inputs properly."
                })
        return issues

    def check_document_write(self):
        issues = []
        for line_num, line in enumerate(self.code.split('\n'), start=1):
            if "document.write(" in line:
                issues.append({
                    "line": line_num,
                    "message": "Use of document.write function found",
                    "fix": "Avoid using document.write function or sanitize inputs properly."
                })
        return issues

    def check_weak_crypto(self):
        issues = []
        weak_crypto_patterns = [
            re.compile(r'crypto.createHash\(["\']md5["\']\)'),
            re.compile(r'crypto.createHash\(["\']sha1["\']\)')
        ]

        for line_num, line in enumerate(self.code.split('\n'), start=1):
            for pattern in weak_crypto_patterns:
                if pattern.search(line):
                    issues.append({
                        "line": line_num,
                        "message": "Weak cryptographic algorithm used",
                        "fix": "Use a stronger cryptographic algorithm such as SHA-256."
                    })
        return issues

    def check_hardcoded_ips(self):
        issues = []
        ip_pattern = re.compile(r'\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b')
        for line_num, line in enumerate(self.code.split('\n'), start=1):
            if ip_pattern.search(line):
                issues.append({
                    "line": line_num,
                    "message": "Hardcoded IP address found",
                    "fix": "Avoid hardcoding IP addresses or configure them through environment variables."
                })
        return issues

    def check_deprecated_libraries(self):
        issues = []
        deprecated_libraries = ["crypto"]
        for line_num, line in enumerate(self.code.split('\n'), start=1):
            for lib in deprecated_libraries:
                if f"require('{lib}')" in line or f'import {lib}' in line:
                    issues.append({
                        "line": line_num,
                        "message": f"Deprecated library '{lib}' used",
                        "fix": f"Use an alternative library that is actively maintained."
                    })
        return issues
